# File name: Logic.py
# Copyright: The AustSTEM Foundation Limited
# Author: Tony Strasser
# Date created: 7 January 2019
# Date last modified: 4 December 2020
# Version 1.4
# MicroPython Version: 1.12 for the Kookaberry V4-06
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation.
# To the fullest extent permitted by law, AustSTEM absolutely disclaims 
# all warranties, expressed or implied, including, but not limited to, 
# implied warranties of merchantability and fitness for any particular purpose. 
# AustSTEM gives no warranty that this software will be free of errors, 
# or that defects in the software will be corrected,  
# See the GNU General Public License for more details.
# Description
# Implements a selection of logic gates between digital inputs and a digital output
# The green, orange and red LEDs indicate the states of the inputs and the logic output
# Begin code
# Instantiate the inputs and output
import machine, kooka, fonts, framebuf
inputA = machine.Pin('P4', machine.Pin.IN, machine.Pin.PULL_DOWN)    # create digital input for button or other digital device
inputB = machine.Pin('P5', machine.Pin.IN, machine.Pin.PULL_DOWN)    # create digital input for button or other digital device
output = machine.Pin('P2', machine.Pin.OUT)    # create the digital output
disp = kooka.display
# Set up the data
logic_ptr = 0
logic_kind = ['AND','OR','NAND','NOR','XOR']
logic_len = len(logic_kind)
inverts = [0] * 2    # stores invert states of inputs
inputs = [0] * 2    # result of input computations
# Set up the graphics arrays
bitmaps = [0] * (logic_len + 1)
icons = [0] * (logic_len + 1)
# Create an inverted signal icon
bitmaps[logic_len] = bytearray([0x00, 0x3C, 0x66, 0x42, 0x42, 0x24, 0x18, 0x00])

icons[logic_len] = framebuf.FrameBuffer(bitmaps[logic_len], 8, 8, framebuf.MONO_VLSB)

# Create an AND gate icon
bitmaps[0] = bytearray([0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x03, 0x03, 0x03, 0x02, 0x06, 0x04, 0x04, 0x04, 0x1C, 0x30, 0x60, 0x40, 0xC0, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1E, 0xF8, 0x80, 0x80, 0x80, 0x80, 0x80,
0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xC0, 0x7C, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x60, 0x20, 0x30, 0x1C, 0x0C, 0x06, 0x07, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])

icons[0] = framebuf.FrameBuffer(bitmaps[0], 59, 32, framebuf.MONO_VLSB)

# Create an OR gate icon
bitmaps[1] = bytearray([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x1D, 0xE1, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02,
0x04, 0x04, 0x04, 0x0C, 0x08, 0x18, 0x30, 0x20, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0xFE, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02, 0x04, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x80,
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
0x80, 0x80, 0xC0, 0x7F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x80, 0xC0, 0x40, 0x20, 0x18, 0x0C, 0x02, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF8, 0xC7, 0xC0,
0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x40,
0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x30, 0x30, 0x10, 0x18, 0x0C, 0x04, 0x02, 0x02, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])

icons[1] = framebuf.FrameBuffer(bitmaps[1], 60, 32, framebuf.MONO_VLSB)

# Create an NAND gate icon
bitmaps[2] = bitmaps[0]    # Use the AND gate
icons[2] = icons[0]

# Create an NOR gate icon
bitmaps[3] = bitmaps[1]    # Use the OR gate
icons[3] = icons[1]

# Create an XOR gate icon
bitmaps[4] = bitmaps[1]    # Use the OR gate
icons[4] = icons[1]

# The main loop begins here
while not kooka.button_a.was_pressed():
    disp.fill(0)
    disp.setfont(fonts.mono8x8)
    disp.text('Logic', 0, 6)
    disp.setfont(fonts.mono6x7)
    disp.text('Ex', 0, 60)
    disp.text('Logic', 94, 60)
    disp.text('P4', 30, 60)
    disp.text('P5', 60, 60)
    disp.text('P4', 0,25)
    disp.text('P5', 0,43)
    disp.text('P2', 115,34)
# Adjust the input logic using the C and D keys
    if kooka.button_c.was_pressed(): inverts[0] = not inverts[0]
    if kooka.button_d.was_pressed(): inverts[1] = not inverts[1]
# Pick the logic gate
    if kooka.button_b.was_pressed():
        logic_ptr += 1
        if logic_ptr >= logic_len: logic_ptr = 0
# Compute the inputs and display
    a = inputA.value()
    b = inputB.value()
    inputs[0] = (a and not inverts[0]) or (not a and inverts[0])
    inputs[1] = (b and not inverts[1]) or (not b and inverts[1])
    disp.setfont(fonts.mono8x13)
    disp.text('%d' % inputs[0], 17,25)
    disp.text('%d' % inputs[1], 17,43)

# Display the logic selection
    disp.blit(icons[logic_ptr], 35, 15)
    if inverts[0]: disp.blit(icons[logic_len], 28, 20)
    if inverts[1]: disp.blit(icons[logic_len], 28, 35)
    if (logic_ptr == 2 or logic_ptr == 3): disp.blit(icons[logic_len], 82, 26)
    disp.setfont(fonts.mono8x13)
    disp.text('%s' % logic_kind[logic_ptr], 50,34)

# Compute the output and display - ['AND','OR','NAND','NOR','XOR']
    if logic_ptr == 0: output.value(inputs[0] and inputs[1])    # AND
    elif logic_ptr == 1: output.value(inputs[0] or inputs[1])    # OR
    elif logic_ptr == 2: output.value(not(inputs[0] and inputs[1])) # NAND
    elif logic_ptr == 3: output.value(not(inputs[0] or inputs[1]))    # NOR
    elif logic_ptr == 4: output.value((inputs[0] and not inputs[1]) or (not inputs[0] and inputs[1]))    # XOR
    disp.text('%d' % output.value(), 100,34)
# Illuminate the LEDs in accordance with the inputs.
    kooka.led_green.off()
    kooka.led_orange.off()
    kooka.led_red.off()
    if inputs[0]: kooka.led_green.on()
    if inputs[1]: kooka.led_orange.on()
    if output.value(): kooka.led_red.on()
    disp.show()

